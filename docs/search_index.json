[["index.html", "Proescholdt Thesis Bookdown Section 1 Introduction 1.1 The Dataset 1.2 My Thesis 1.3 This Book", " Proescholdt Thesis Bookdown Toni Proescholdt 2021-04-30 Section 1 Introduction This book is for my masters thesis. I will submit a version of it as my final project for Dr. Simona Picardis course WILD6900 at Utah State University in the Spring semester of 2021. I will continue to use it and add to it as I work on my project. 1.1 The Dataset I am analyzing data from a long-term study on bighorn sheep at the Bison Range in western Montana. This study was started by Dr. Jack Hogg in 1979 and has been running ever since. Dr. Hogg established identifying marks for each individual in the population. He has collected behavioral, location, and group composition data (and more!) from this herd over these last 40 years. (#fig:sheep pic)Rug and Yaya on the Bison Range 1.2 My Thesis I am using this dataset to study the fission-fusion dynamics of this population of bighorn sheep. 1.2.1 Thesis Abstract Social species can be described by the degree to which they display fission-fusion dynamics through variation in three dimensions: group size, composition, and spatial cohesion. These factors directly affect social structure of a population, but they are complex, infrequently measured in the wild, and rarely linked to underlying social processes such as relatedness or shared life stage. Identifying the critical processes that shape female social structure and fission-fusion dynamics is an important step toward accurately forecasting how animals interact and spread disease. Here, I propose a masters thesis to estimate fission-fusion dimensions and link fission-fusion events to social processes and fitness outcomes using a long-term, individual-level dataset on bighorn sheep from the Bison Range in Montana. In Chapter 1, I will examine the variance in group composition, group size, and group spatial cohesion and assess whether aspects of those variances can be systematically explained by changes in population size, age, or sex structure. I will then compare the rates of fission and fusion events to learn which appears to drive the bulk of group composition change. In Chapter 2, I will model group switching choices as a function of social covariates through a discrete choice model. The discrete choice model will contrast conditions such as pedigree, cohort, reproductive status, and group size preference in an animals chosen group to conditions on all other groups detected that day. Finally, I will investigate the immediate fitness implications of fission-fusion events by tallying the times that a fission or fusion event corresponds with the date an animal was last seen alive. In this proposal, I will describe project objectives and hypotheses, as well as some preliminary findings derived from early data exploration. 1.3 This Book Section 2 is about making the database itself. This includes setting up the database tables and filling those tables with data. Section 3 explores parentage of this population to see how many lambs the most successful parents had. Section @ref(grp_size) investigates aspects of group size, like how big the biggest groups were, when did the biggest groups occur, and what is the mean and mode group size. (#fig:range pic)The Bison Range "],["build.html", "Section 2 Building the Database 2.1 Database Design 2.2 Building the Tables 2.3 Importing Data", " Section 2 Building the Database This Markdown served as my submission for Assignment 6 in WILD6900: Computational Tools for Reproducible Science Professor: Dr. Simona Picardi. It is also an integral part of my final project. In this document I will detail my project database. knitr::opts_chunk$set(echo = TRUE, eval = TRUE) #First, I will install and load packages. #install.packages(&quot;RSQLite&quot;) #install.packages(&quot;DBI&quot;) library(DBI) library(tidyverse) ## -- Attaching packages --------------------------------------- tidyverse 1.3.0 -- ## v ggplot2 3.3.3 v purrr 0.3.4 ## v tibble 3.0.6 v dplyr 1.0.5 ## v tidyr 1.1.3 v stringr 1.4.0 ## v readr 1.4.0 v forcats 0.5.1 ## -- Conflicts ------------------------------------------ tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() #Then I will establish a database connection. sheep &lt;- dbConnect(drv = RSQLite::SQLite(), &quot;../../../WILD6900_Comp-Tools/sheep.db&quot;) 2.1 Database Design Now that I have a database connection set up, I will build my database through tables in the structure based on the design below. Figure 2.1: Database layout 2.2 Building the Tables Now I will create and fill my tables within the database, using the help of information from our class website: https://ecorepsci.github.io/reproducible-science/rsqlite.html. I will build a table via RSQLite for each table in my design. #make table for individuals dbExecute(sheep, &quot;CREATE TABLE individuals ( name varchar(30) NOT NULL, id_number varchar(8), sex char(1), year_born char(4), year_death char(4), mother_idno varchar(8), father_idno varchar(8), PRIMARY KEY (name) );&quot;) #Make table for Fecal Samples dbExecute(sheep, &quot;CREATE TABLE fecal ( sample_id varchar(10), name varchar(30) NOT NULL, date varchar(8), time varchar(5), FOREIGN KEY (name) REFERENCES individuals(name) );&quot;) #Make table for vigilance observations dbExecute(sheep, &quot;CREATE TABLE vigilance ( observation_id INTEGER PRIMARY KEY AUTOINCREMENT, name varchar(30) NOT NULL, date varchar(8), time varchar(5), FOREIGN KEY (name) REFERENCES individuals(name) );&quot;) #Make table for all observers dbExecute(sheep, &quot;CREATE TABLE observers ( observer_id INTEGER PRIMARY KEY AUTOINCREMENT, full_name char(30), initials char(3), year_start integer(4), year_stop integer(4) );&quot;) #Make table for census data dbExecute(sheep, &quot;CREATE TABLE census ( group_record_id INTEGER PRIMARY KEY AUTOINCREMENT, observed_group_no varchar(3) NOT NULL, date varchar(8), time varchar(4), obs_init char(3), group_size integer(3) );&quot;) #Removed these for now until I can get more data for the observers table #observer_id integer(3), #FOREIGN KEY (observer_id) REFERENCES observers(observer_id) #Make table for Group Locations dbExecute(sheep, &quot;CREATE TABLE group_locations ( location_id INTEGER PRIMARY KEY AUTOINCREMENT, group_record_id INTEGER(6), map varchar(10), latitude varchar(8), longitude varchar(8), FOREIGN KEY (group_record_id) REFERENCES census(group_record_id) );&quot;) #Make table for Group Composition dbExecute(sheep, &quot;CREATE TABLE group_composition ( observation_id INTEGER PRIMARY KEY AUTOINCREMENT, group_record_id INTEGER(6), name varchar(30), lamb_status varchar(5), FOREIGN KEY (group_record_id) REFERENCES census(group_record_id), FOREIGN KEY (name) REFERENCES individuals(name) );&quot;) #Drop table if need to change dbExecute(sheep, &quot;DROP TABLE census&quot;); 2.3 Importing Data Now that I have all of my tables built, I will import my data into them. #Individuals ---- #Bring in data individuals_ &lt;- read.csv(&quot;../../tables/Individuals.csv&quot;) head(individuals) names(individuals_)[2] &lt;- &quot;id_number&quot; individuals &lt;- individuals_ %&gt;% select(-X) #Change names names(individuals)[1] &lt;- &quot;X&quot; names(individuals)[4] &lt;- &quot;year_born&quot; names(individuals)[5] &lt;- &quot;year_death&quot; names(individuals)[7] &lt;- &quot;mother_idno&quot; names(individuals)[7] &lt;- &quot;father_idno&quot; #Fill table dbWriteTable(sheep, &quot;individuals&quot;, individuals, append = TRUE) #Check that it worked dbGetQuery(conn = sheep, statement = &quot;SELECT * FROM individuals LIMIT 10&quot;) #Set connection individuals &lt;- dbGetQuery(sheep, &quot;SELECT * FROM individuals;&quot;) #Fecal ---- #Bring in data fecal_full &lt;- read.csv(&quot;../../tables/NBR Fecal Samples Fall 2019.csv&quot;) head(fecal_full) fecal &lt;- fecal_full[ , c(5, 3, 1, 2)] #Change names names(fecal)[1] &lt;- &quot;sample_id&quot; names(fecal)[2] &lt;- &quot;name&quot; names(fecal)[3] &lt;- &quot;date&quot; names(fecal)[4] &lt;- &quot;time&quot; head(fecal) #Fill table dbWriteTable(sheep, &quot;fecal&quot;, fecal, append = TRUE) #Check that it worked dbGetQuery(conn = sheep, statement = &quot;SELECT * FROM fecal LIMIT 10&quot;) #Set connection fecal &lt;- dbGetQuery(sheep, &quot;SELECT * FROM fecal;&quot;) #Cen, loc, comp ---- #Bring in data to split for census, locations, and composition BRCEN &lt;- read.csv(&quot;../../Raw_Data/census_withLatLong_20200511.csv&quot;) head(BRCEN) names(BRCEN) #Census ---- #subset for census table census &lt;- BRCEN[ , c(4, 3, 2, 14)] head(census) #Change names names(census)[2] &lt;- &quot;observed_group_no&quot; names(census)[2] &lt;- &quot;time&quot; names(census)[5] &lt;- &quot;group_size&quot; names(census)[4] &lt;- &quot;obs_init&quot; #Fill table dbWriteTable(sheep, &quot;census&quot;, census, append = TRUE) #Check that it worked dbGetQuery(conn = sheep, statement = &quot;SELECT * FROM census LIMIT 10&quot;) #Excellent. #Now I need to do some wrangling to get it specific to the group #I need to use it as a primary key in the next two tables. library(tidyverse) census &lt;- BRCEN %&gt;% as_tibble() %&gt;% select(groupid, time, date, obs) %&gt;% group_by(date, groupid, time, obs) %&gt;% tally() %&gt;% mutate(grp_size = n) %&gt;% filter(!is.na(groupid)) %&gt;% select(-n) #Set connection census &lt;- dbGetQuery(sheep, &quot;SELECT * FROM census;&quot;) #Locations ---- #Subset for group locations locations &lt;- BRCEN[ , c(18, 20, 19)] head(locations) #Change names names(locations)[2] &lt;- &quot;latitude&quot; names(locations)[3] &lt;- &quot;longitude&quot; #Fill table dbWriteTable(sheep, &quot;group_locations&quot;, locations, append = TRUE) #Check that it worked dbGetQuery(conn = sheep, statement = &quot;SELECT * FROM group_locations LIMIT 10&quot;) #Set connection group_locations &lt;- dbGetQuery(sheep, &quot;SELECT * FROM locations;&quot;) #Composition ---- #Subset for individuals in each group names(BRCEN) group_composition &lt;- composition[ , c(5, 6)] #Change names names(composition)[5] &lt;- &quot;name&quot; names(composition)[6] &lt;- &quot;lamb_status&quot; #Rearrange to match census composition &lt;- BRCEN %&gt;% as_tibble() %&gt;% select(groupid, time, date, obs, fulltag_clean, lamb_present) %&gt;% group_by(date, groupid, time, obs) #Fill table dbWriteTable(sheep, &quot;group_composition&quot;, group_composition, append = TRUE) #Check that it worked dbGetQuery(conn = sheep, statement = &quot;SELECT * FROM group_composition LIMIT 10&quot;) #Set connection group_composition &lt;- dbGetQuery(sheep, &quot;SELECT * FROM group_composition;&quot;) #Need to go back through and solidify tables in db, specifically #census to use it to build the locations table based on the unique #group record id. composition needs this too. This assignment shows my work flow for building my database and getting used to Rmarkdown. The assignment, along with my Assignment 7 bookdown, build to the final project. "],["parents.html", "Section 3 Exploring Parentage", " Section 3 Exploring Parentage Now that I have my database all set up, I can explore the data. I want to know who were the most successful ewes in reproductive fitness, so Im going to use the mother_idno to track how many times it shows up for each ewe. best_moms &lt;- individuals %&gt;% select(name, mother_idno) %&gt;% group_by(mother_idno) %&gt;% tally() %&gt;% arrange(desc(n)) best_best_moms &lt;- best_moms[c(2:21), ] best_best_moms %&gt;% ggplot(mapping = aes(x = mother_idno, y = n, fill = mother_idno)) + geom_col() + labs(title = &quot;Lambs by Mom&quot;, x = &quot;mother id number&quot;, y = &quot;number of lambs&quot;, fill = &quot;mother_idno&quot;) + theme(axis.text.x = element_text(angle = 45, hjust=1)) Im surprised that there were so many ewes over the years who had more than 10 lambs! In the future, I would like to examine these data further and parse out how long those lambs lived. It could be that some of these ewes had many lambs, but only a few of those survived to adulthood. I would also like to take into account the family tree below each ewe to see how many grandchildren she had. Because we have data for both parents of each animal, I can track the reproductive fitness of the rams too. best_dads &lt;- individuals %&gt;% filter(!is.na(father_idno)) %&gt;% select(name, father_idno) %&gt;% group_by(father_idno) %&gt;% tally() %&gt;% arrange(desc(n)) best_best_dads &lt;- best_dads[c(2:21), ] best_best_dads %&gt;% ggplot(mapping = aes(x = father_idno, y = n, fill = father_idno)) + geom_col() + labs(title = &quot;Lambs by Dad&quot;, x = &quot;father id number&quot;, fill = &quot;father_idno&quot;) + theme(axis.text.x = element_text(angle = 45, hjust=1)) One thing to note in this comparison is that there are 83 animals without data for a mother_idno, whereas there are 583 animals without data for a father_idno! My instinct is that this is due to so many lambs over the years dying before they could be sampled for genetic material. Its much easier to record a mother for a lamb by observation alone. The top father on this list is ram 00-03, who was the father of 21 lambs who survived long enough to sample for lineage. individuals %&gt;% select(id_number, name) %&gt;% filter(id_number == c(&quot;ID00-03&quot;, &quot;ID00-02&quot;)) ## id_number name ## 1 ID00-02 MAGPIE ## 2 ID00-03 NAVEL Our best dad was Navel, and our best mom was Magpie. Its funny that they were both born in the same year, but I guess that was a good time period to be born into. Now lets see who their children were. Magpies &lt;- individuals %&gt;% filter(mother_idno == &quot;ID00-02&quot;) Navels &lt;- individuals %&gt;% filter(father_idno == &quot;ID00-03&quot;) "],["grp-size.html", "Section 4 Group Size", " Section 4 Group Size One of my main questions is about group size, and how it scales with population. To investigate this, I will first need to examine the group size. #What was the biggest group observed and when? census %&gt;% as_tibble %&gt;% select(group_size, date) %&gt;% group_by(group_size) %&gt;% arrange(desc(group_size)) ## # A tibble: 21,204 x 2 ## # Groups: group_size [70] ## group_size date ## &lt;int&gt; &lt;chr&gt; ## 1 85 06/15/2014 ## 2 80 06/04/2015 ## 3 80 06/20/2015 ## 4 79 10/27/2014 ## 5 77 11/07/2014 ## 6 74 09/28/2012 ## 7 73 10/25/2015 ## 8 71 06/07/2014 ## 9 68 10/29/2013 ## 10 67 09/07/2013 ## # ... with 21,194 more rows It looks like the largest group was observed in June of 2014, and it was 85 individuals! I am curious about what group size is observed most frequently and what the average group size is for the whole dataset. Now, I want to know more about how group size is related to other factors like population size and sex ratio. To start exploring this, I want to look into when groups of different sizes occur and how that has changed over the 40 years in this dataset. "],["population.html", "Section 5 Population 5.1 Example one 5.2 Example two", " Section 5 Population 5.1 Example one 5.2 Example two "],["final-words.html", "Section 6 Final Words", " Section 6 Final Words More graphs, probably. "],["references.html", "References", " References "]]
